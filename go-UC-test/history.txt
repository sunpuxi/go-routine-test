【专题1：CPU 型并发基础 - goroutine 入门】
时间：2025-11-29
前置水平：只会基础 go func() 和 time.Sleep
目标：掌握用 goroutine 做 CPU 计算加速的基本套路（拆分任务 -> 启 goroutine -> 汇总结果）

练习1（简单）：并发求 1..N 的平方和
要求：
1）开启多个 goroutine，每个负责一段区间的求和，例如 [1,1000]、[1001,2000] ...
2）用 sync.WaitGroup 等待所有 goroutine 完成
3）在主 goroutine 汇总所有部分和，和单线程结果做对比

练习2（中等）：并发计算数组中每个元素的复杂函数值
场景：给定一个长度为 1e6 的 int 列表，对每个元素做一个“假装很重”的计算（比如循环做若干次平方/开方），然后求总和
要求：
1）实现串行版本，记录耗时
2）实现固定 worker 数的并发版本（例如 4/8 个 worker），比较耗时
3）注意：不得使用全局锁保护一个共享 sum，而是使用“每个 worker 局部 sum + 最终汇总”的方式

练习3（困难）：自适应分片的并行计算器
场景：计算 f(i) = 重计算( i ) 的总和，i=1..N。重计算耗时不均匀（例如偶数比奇数更慢）
要求：
1）实现一个 worker pool，worker 从一个“任务 channel”中拿任务，直到任务耗尽
2）任务是“一个 i”，worker 负责计算 f(i) 并把结果发回结果 channel
3）主 goroutine 负责派发 1..N 到任务 channel，并从结果 channel 里收集所有结果并求和
4）N 可以配置为比较大（比如 2e5），并可以配置 worker 数量，观察不同 worker 数量下耗时变化

备注：以上练习的代码示例/骨架将在对应 .go 文件中提供，后续新增专题会继续在本文件追加记录。

【专题2：IO 密集型并发 - 网络请求与超时控制】
时间：2025-11-29
前置水平：已完成专题1，掌握 goroutine + WaitGroup + channel 基础
目标：掌握 IO 密集型任务的并发处理，学会用 context 控制超时、取消，以及 worker pool 限流

练习1（简单）：并发发起多个 HTTP 请求
场景：需要从多个 URL 获取数据，串行太慢，用并发加速
要求：
1）实现串行版本和并发版本，对比耗时
2）用 sync.WaitGroup 等待所有请求完成
3）注意：每个 goroutine 要正确处理闭包变量捕获（避免 race condition）

练习2（中等）：带超时控制的并发请求
场景：多个请求中，有些可能很慢或卡死，需要设置超时，超时的请求直接放弃
要求：
1）使用 context.WithTimeout 为每个请求设置独立超时
2）超时的请求要能正确识别（context.DeadlineExceeded）
3）统计成功/超时/失败的数量

练习3（困难）：带重试、限流、错误处理的并发请求聚合
场景：真实生产环境，需要处理失败重试、控制并发数、收集所有结果
要求：
1）使用 worker pool 控制并发数（例如最多3个并发请求）
2）失败自动重试（最多重试2次）
3）所有请求完成后，统计成功/失败数量、总尝试次数
4）注意：重试要有退避策略（避免立即重试导致服务器压力）

【专题3：并发安全与同步原语】
时间：2025-11-30
前置水平：已完成专题1和专题2，掌握 goroutine、channel、WaitGroup、context
目标：掌握并发安全编程，学会使用 Mutex、RWMutex、Atomic 等同步原语，避免竞态条件

练习1（简单）：使用 Mutex 保护共享变量
场景：多个 goroutine 同时修改一个计数器
要求：
1）实现一个线程安全的 Counter，使用 sync.Mutex 保护共享变量
2）对比不使用锁的版本，观察竞态条件导致的数据丢失
3）理解 Mutex 的基本用法：Lock() 和 Unlock()

练习2（中等）：使用 RWMutex 优化读写分离
场景：多读少写的场景（如缓存），使用读写锁提升性能
要求：
1）实现一个线程安全的 Cache，使用 sync.RWMutex
2）读操作使用 RLock()（允许多个 goroutine 同时读）
3）写操作使用 Lock()（独占访问）
4）对比 RWMutex 和普通 Mutex 在多读场景下的性能差异

练习3（困难）：原子操作 vs Mutex 性能对比
场景：简单的计数器操作，对比 atomic 和 mutex 的性能
要求：
1）实现三种线程安全的计数器：
   - 使用 Mutex 的版本
   - 使用 atomic.AddInt64 的版本
   - 使用 atomic.CompareAndSwapInt64 (CAS) 的版本
2）对比三种实现的性能
3）理解 atomic 的适用场景：简单操作（如自增）用 atomic 更高效

备注：以上练习的代码示例/骨架将在对应 .go 文件中提供，后续新增专题会继续在本文件追加记录。
