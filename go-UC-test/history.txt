【专题1：CPU 型并发基础 - goroutine 入门】
时间：2025-11-29
前置水平：只会基础 go func() 和 time.Sleep
目标：掌握用 goroutine 做 CPU 计算加速的基本套路（拆分任务 -> 启 goroutine -> 汇总结果）

练习1（简单）：并发求 1..N 的平方和
要求：
1）开启多个 goroutine，每个负责一段区间的求和，例如 [1,1000]、[1001,2000] ...
2）用 sync.WaitGroup 等待所有 goroutine 完成
3）在主 goroutine 汇总所有部分和，和单线程结果做对比

练习2（中等）：并发计算数组中每个元素的复杂函数值
场景：给定一个长度为 1e6 的 int 列表，对每个元素做一个“假装很重”的计算（比如循环做若干次平方/开方），然后求总和
要求：
1）实现串行版本，记录耗时
2）实现固定 worker 数的并发版本（例如 4/8 个 worker），比较耗时
3）注意：不得使用全局锁保护一个共享 sum，而是使用“每个 worker 局部 sum + 最终汇总”的方式

练习3（困难）：自适应分片的并行计算器
场景：计算 f(i) = 重计算( i ) 的总和，i=1..N。重计算耗时不均匀（例如偶数比奇数更慢）
要求：
1）实现一个 worker pool，worker 从一个“任务 channel”中拿任务，直到任务耗尽
2）任务是“一个 i”，worker 负责计算 f(i) 并把结果发回结果 channel
3）主 goroutine 负责派发 1..N 到任务 channel，并从结果 channel 里收集所有结果并求和
4）N 可以配置为比较大（比如 2e5），并可以配置 worker 数量，观察不同 worker 数量下耗时变化

备注：以上练习的代码示例/骨架将在对应 .go 文件中提供，后续新增专题会继续在本文件追加记录。

【专题2：IO 密集型并发 - 网络请求与超时控制】
时间：2025-11-29
前置水平：已完成专题1，掌握 goroutine + WaitGroup + channel 基础
目标：掌握 IO 密集型任务的并发处理，学会用 context 控制超时、取消，以及 worker pool 限流

练习1（简单）：并发发起多个 HTTP 请求
场景：需要从多个 URL 获取数据，串行太慢，用并发加速
要求：
1）实现串行版本和并发版本，对比耗时
2）用 sync.WaitGroup 等待所有请求完成
3）注意：每个 goroutine 要正确处理闭包变量捕获（避免 race condition）

练习2（中等）：带超时控制的并发请求
场景：多个请求中，有些可能很慢或卡死，需要设置超时，超时的请求直接放弃
要求：
1）使用 context.WithTimeout 为每个请求设置独立超时
2）超时的请求要能正确识别（context.DeadlineExceeded）
3）统计成功/超时/失败的数量

练习3（困难）：带重试、限流、错误处理的并发请求聚合
场景：真实生产环境，需要处理失败重试、控制并发数、收集所有结果
要求：
1）使用 worker pool 控制并发数（例如最多3个并发请求）
2）失败自动重试（最多重试2次）
3）所有请求完成后，统计成功/失败数量、总尝试次数
4）注意：重试要有退避策略（避免立即重试导致服务器压力）

【专题3：并发安全与同步原语】
时间：2025-11-30
前置水平：已完成专题1和专题2，掌握 goroutine、channel、WaitGroup、context
目标：掌握并发安全编程，学会使用 Mutex、RWMutex、Atomic 等同步原语，避免竞态条件

练习1（简单）：使用 Mutex 保护共享变量
场景：多个 goroutine 同时修改一个计数器
要求：
1）实现一个线程安全的 Counter，使用 sync.Mutex 保护共享变量
2）对比不使用锁的版本，观察竞态条件导致的数据丢失
3）理解 Mutex 的基本用法：Lock() 和 Unlock()

练习2（中等）：使用 RWMutex 优化读写分离
场景：多读少写的场景（如缓存），使用读写锁提升性能
要求：
1）实现一个线程安全的 Cache，使用 sync.RWMutex
2）读操作使用 RLock()（允许多个 goroutine 同时读）
3）写操作使用 Lock()（独占访问）
4）对比 RWMutex 和普通 Mutex 在多读场景下的性能差异

练习3（困难）：原子操作 vs Mutex 性能对比
场景：简单的计数器操作，对比 atomic 和 mutex 的性能
要求：
1）实现三种线程安全的计数器：
   - 使用 Mutex 的版本
   - 使用 atomic.AddInt64 的版本
   - 使用 atomic.CompareAndSwapInt64 (CAS) 的版本
2）对比三种实现的性能
3）理解 atomic 的适用场景：简单操作（如自增）用 atomic 更高效

【专题4：Channel 高级用法与并发模式】
时间：2025-12-01
前置水平：已完成专题1-3，掌握 goroutine、channel、Mutex、Atomic 基础
目标：掌握 Channel 的高级用法（select、扇入扇出、管道），学会常见的并发模式

练习1（简单）：使用 select 实现超时控制
场景：从多个 channel 接收数据，需要设置超时
要求：
1）使用 select 语句实现非阻塞接收
2）使用 time.After 实现超时控制
3）理解 select 的多路复用机制

练习2（中等）：扇入模式（Fan-In）
场景：多个 channel 的数据需要合并到一个 channel
要求：
1）实现扇入函数，将多个输入 channel 合并为一个输出 channel
2）为每个输入 channel 启动一个 goroutine
3）使用 WaitGroup 等待所有输入完成并关闭输出 channel

练习3（困难）：管道模式（Pipeline）
场景：数据处理流水线，多个阶段依次处理数据
要求：
1）实现一个管道，数据依次经过多个处理阶段
2）每个阶段是一个函数，接收一个 channel，返回一个 channel
3）理解管道的组合性和可扩展性

备注：以上练习的代码示例/骨架将在对应 .go 文件中提供，后续新增专题会继续在本文件追加记录。

【专题5：Sync 包高级特性与并发工具】
时间：2025-12-02
前置水平：已完成专题1-4，掌握 goroutine、channel、Mutex、RWMutex、Atomic 基础
目标：掌握 sync 包中的高级同步工具（Once、Pool、Map、Cond），了解它们的适用场景和性能特点

练习1（简单）：sync.Once 实现单例模式和延迟初始化
场景：某些资源只需要初始化一次，即使多个 goroutine 并发调用也应该只执行一次
要求：
1）使用 sync.Once 实现一个线程安全的单例模式
2）对比不使用 Once 的版本，观察多次初始化的问题
3）理解 Once.Do() 的语义：只执行一次，即使多个 goroutine 同时调用
4）实现一个延迟初始化的配置管理器，多个 goroutine 可以安全地获取配置

练习2（中等）：sync.Pool 实现对象池复用
场景：频繁创建和销毁对象会带来 GC 压力，使用对象池可以减少内存分配
要求：
1）实现一个基于 sync.Pool 的对象池，用于复用临时对象（如 buffer）
2）对比使用 Pool 和不使用 Pool 的性能差异（内存分配次数、GC 压力）
3）理解 Pool 的工作原理：Get() 从池中获取，Put() 归还对象
4）注意：Pool 中的对象随时可能被 GC 回收，不能假设对象一直存在

练习3（困难）：sync.Map 并发安全映射和 sync.Cond 条件变量
场景：高并发场景下的 map 操作，以及复杂的线程间协调需求
要求：
1）使用 sync.Map 实现一个线程安全的缓存，支持 Store、Load、Delete、Range 操作
2）对比 sync.Map 和 "map + Mutex" 在不同读写比例下的性能
3）使用 sync.Cond 实现一个生产者-消费者模型，当队列为空时消费者等待，队列满时生产者等待
4）理解 Cond 的使用模式：Wait() 前必须持有锁，Signal()/Broadcast() 唤醒等待的 goroutine
5）实现一个任务队列，支持阻塞式的 Put 和 Take 操作

备注：以上练习的代码示例/骨架将在对应 .go 文件中提供，后续新增专题会继续在本文件追加记录。