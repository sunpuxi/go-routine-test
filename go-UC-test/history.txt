【专题1：CPU 型并发基础 - goroutine 入门】
时间：2025-11-29
前置水平：只会基础 go func() 和 time.Sleep
目标：掌握用 goroutine 做 CPU 计算加速的基本套路（拆分任务 -> 启 goroutine -> 汇总结果）

练习1（简单）：并发求 1..N 的平方和
要求：
1）开启多个 goroutine，每个负责一段区间的求和，例如 [1,1000]、[1001,2000] ...
2）用 sync.WaitGroup 等待所有 goroutine 完成
3）在主 goroutine 汇总所有部分和，和单线程结果做对比

练习2（中等）：并发计算数组中每个元素的复杂函数值
场景：给定一个长度为 1e6 的 int 列表，对每个元素做一个“假装很重”的计算（比如循环做若干次平方/开方），然后求总和
要求：
1）实现串行版本，记录耗时
2）实现固定 worker 数的并发版本（例如 4/8 个 worker），比较耗时
3）注意：不得使用全局锁保护一个共享 sum，而是使用“每个 worker 局部 sum + 最终汇总”的方式

练习3（困难）：自适应分片的并行计算器
场景：计算 f(i) = 重计算( i ) 的总和，i=1..N。重计算耗时不均匀（例如偶数比奇数更慢）
要求：
1）实现一个 worker pool，worker 从一个“任务 channel”中拿任务，直到任务耗尽
2）任务是“一个 i”，worker 负责计算 f(i) 并把结果发回结果 channel
3）主 goroutine 负责派发 1..N 到任务 channel，并从结果 channel 里收集所有结果并求和
4）N 可以配置为比较大（比如 2e5），并可以配置 worker 数量，观察不同 worker 数量下耗时变化

备注：以上练习的代码示例/骨架将在对应 .go 文件中提供，后续新增专题会继续在本文件追加记录。

【专题2：IO 密集型并发 - 网络请求与超时控制】
时间：2025-11-29
前置水平：已完成专题1，掌握 goroutine + WaitGroup + channel 基础
目标：掌握 IO 密集型任务的并发处理，学会用 context 控制超时、取消，以及 worker pool 限流

练习1（简单）：并发发起多个 HTTP 请求
场景：需要从多个 URL 获取数据，串行太慢，用并发加速
要求：
1）实现串行版本和并发版本，对比耗时
2）用 sync.WaitGroup 等待所有请求完成
3）注意：每个 goroutine 要正确处理闭包变量捕获（避免 race condition）

练习2（中等）：带超时控制的并发请求
场景：多个请求中，有些可能很慢或卡死，需要设置超时，超时的请求直接放弃
要求：
1）使用 context.WithTimeout 为每个请求设置独立超时
2）超时的请求要能正确识别（context.DeadlineExceeded）
3）统计成功/超时/失败的数量

练习3（困难）：带重试、限流、错误处理的并发请求聚合
场景：真实生产环境，需要处理失败重试、控制并发数、收集所有结果
要求：
1）使用 worker pool 控制并发数（例如最多3个并发请求）
2）失败自动重试（最多重试2次）
3）所有请求完成后，统计成功/失败数量、总尝试次数
4）注意：重试要有退避策略（避免立即重试导致服务器压力）
