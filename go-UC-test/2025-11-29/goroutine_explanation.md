# Goroutine 工作原理详解

## 一、什么是 Goroutine？

**Goroutine = Go + Routine（例程）**

- **轻量级线程**：由 Go 运行时管理的用户态线程
- **协程（Coroutine）**：可以暂停和恢复的执行流
- **特点**：创建成本低（几KB栈空间），可以创建百万级 goroutine

---

## 二、Goroutine vs 线程

### 2.1 传统线程模型（1:1）

```
操作系统线程（OS Thread）
├── 每个线程 = 1MB 栈空间
├── 线程切换需要系统调用（内核态切换，成本高）
├── 创建线程成本高（几毫秒）
└── 通常只能创建几千个线程
```

### 2.2 Goroutine 模型（M:N）

```
Go 运行时（Runtime）
├── M 个 OS 线程（Machine，对应操作系统线程）
├── N 个 Goroutine（用户态协程）
└── 多个 Goroutine 复用在少量 OS 线程上
```

**优势**：
- Goroutine 创建成本低（2KB 初始栈，可动态增长）
- 切换在用户态完成（无需系统调用）
- 可以创建百万级 goroutine

---

## 三、G-M-P 调度模型（Go 1.1+）

### 3.1 三个核心组件

```
G (Goroutine)
├── 代表一个 goroutine
├── 包含：栈、程序计数器（PC）、寄存器状态
└── 存储：goroutine 的执行上下文

M (Machine)
├── 代表一个 OS 线程
├── 绑定一个 P，执行 G
└── 数量 ≈ CPU 核心数（GOMAXPROCS）

P (Processor)
├── 代表一个"逻辑处理器"
├── 维护一个本地 G 队列（Local Queue）
├── 数量 = GOMAXPROCS（默认 = CPU 核心数）
└── 每个 P 绑定一个 M
```

### 3.2 调度关系图

```
┌─────────────────────────────────────────┐
│          Go Runtime Scheduler            │
├─────────────────────────────────────────┤
│                                         │
│  ┌─────┐    ┌─────┐    ┌─────┐         │
│  │ P1  │    │ P2  │    │ P3  │  ...   │  (Processor，逻辑处理器)
│  └──┬──┘    └──┬──┘    └──┬──┘         │
│     │          │          │            │
│  ┌──▼──┐    ┌──▼──┐    ┌──▼──┐        │
│  │ M1  │    │ M2  │    │ M3  │  ...   │  (Machine，OS 线程)
│  └─────┘    └─────┘    └─────┘        │
│     │          │          │            │
│  ┌──▼──┐    ┌──▼──┐    ┌──▼──┐        │
│  │ G1  │    │ G5  │    │ G9  │        │  (Goroutine，正在执行)
│  │ G2  │    │ G6  │    │ G10 │        │
│  │ G3  │    │ G7  │    │ ... │        │  (本地队列，等待执行)
│  │ G4  │    │ G8  │    │     │        │
│  └─────┘    └─────┘    └─────┘        │
│                                         │
│  ┌───────────────────────────────┐   │
│  │    Global Queue (全局队列)     │   │  (所有 P 共享)
│  └───────────────────────────────┘   │
└─────────────────────────────────────────┘
```

---

## 四、Goroutine 的生命周期

### 4.1 创建阶段

```go
go func() {
    // 新 goroutine
}()
```

**执行流程**：
1. 分配 G 结构体（2KB 初始栈）
2. 设置 G 的入口函数和参数
3. 将 G 放入当前 P 的本地队列（或全局队列）
4. 如果当前 P 的 M 空闲，唤醒 M 执行

### 4.2 执行阶段

```
M (OS 线程) 从 P 的本地队列取 G → 执行 G → G 完成/阻塞 → 取下一个 G
```

### 4.3 阻塞阶段

当 G 遇到阻塞操作（如 channel、系统调用）：

```
1. G 进入阻塞状态
2. M 与 P 解绑（M 可以继续执行其他 G）
3. P 从本地队列或全局队列取新的 G 执行
4. 阻塞的 G 等待条件满足后，重新进入可运行队列
```

### 4.4 调度时机

**主动让出（Cooperative）**：
- `runtime.Gosched()`：主动让出 CPU
- Channel 操作：发送/接收时可能阻塞
- 系统调用：如 `time.Sleep()`、网络 IO

**被动抢占（Preemptive，Go 1.14+）**：
- 运行时间过长（>10ms）的 G 会被标记，在函数调用时被抢占
- 保证公平性，避免某个 G 长时间占用 CPU

---

## 五、实际运行示例

### 5.1 简单示例

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    // 创建 3 个 goroutine
    for i := 0; i < 3; i++ {
        go func(id int) {
            fmt.Printf("Goroutine %d 开始\n", id)
            time.Sleep(100 * time.Millisecond)
            fmt.Printf("Goroutine %d 结束\n", id)
        }(i)
    }
    
    time.Sleep(200 * time.Millisecond)
}
```

**执行流程**：
```
T1: main goroutine 创建 G1, G2, G3
T2: G1, G2, G3 进入 P 的本地队列
T3: M 从队列取 G1 执行 → G1 调用 time.Sleep（阻塞）
T4: M 取 G2 执行 → G2 调用 time.Sleep（阻塞）
T5: M 取 G3 执行 → G3 调用 time.Sleep（阻塞）
T6: time.Sleep 到期，G1, G2, G3 重新进入可运行队列
T7: M 依次执行 G1, G2, G3 的后续代码
```

### 5.2 Channel 阻塞示例

```go
ch := make(chan int)

go func() {
    ch <- 42  // 发送：如果 channel 满，G 阻塞
}()

value := <-ch  // 接收：如果 channel 空，G 阻塞
```

**调度细节**：
- 发送方 G 阻塞 → M 与 P 解绑 → P 执行其他 G
- 接收方 G 阻塞 → M 与 P 解绑 → P 执行其他 G
- 当 channel 有数据/空间时，阻塞的 G 被唤醒

---

## 六、关键特性

### 6.1 栈管理

**动态栈**：
- 初始栈：2KB（比线程的 1MB 小得多）
- 可动态增长（最大 1GB）
- 栈不足时自动扩容，栈过大时自动缩容

**分段栈（Go 1.0-1.2）**：
- 栈是多个段，通过指针链接
- 问题：栈分裂/合并成本高

**连续栈（Go 1.3+）**：
- 栈是连续内存，扩容时复制到新位置
- 性能更好，但复制有成本

### 6.2 调度策略

**工作窃取（Work Stealing）**：
- 如果 P 的本地队列空了，会从其他 P 的队列"偷" G
- 保证负载均衡，充分利用 CPU

**自旋（Spinning）**：
- M 空闲时不会立即休眠，而是"自旋"等待新任务
- 减少线程切换成本

### 6.3 GOMAXPROCS

```go
runtime.GOMAXPROCS(4)  // 设置 P 的数量 = 4
```

- 默认 = CPU 核心数
- 控制同时运行的 OS 线程数（M 的数量）
- 通常不需要修改，除非有特殊需求

---

## 七、性能优势

### 7.1 创建成本对比

```
OS 线程：     ~1-2ms，栈 1MB
Goroutine：   ~几微秒，栈 2KB
```

### 7.2 切换成本对比

```
OS 线程切换： 需要进入内核态，保存/恢复寄存器，成本高
Goroutine 切换：在用户态完成，只保存必要的上下文，成本低
```

### 7.3 并发能力

```
OS 线程：     通常几千个（受限于内存和系统限制）
Goroutine：   可以创建百万级（受限于内存，但栈很小）
```

---

## 八、常见问题

### Q1: Goroutine 是线程吗？
**A**: 不是。Goroutine 是用户态协程，多个 goroutine 复用在少量 OS 线程上。

### Q2: 为什么可以创建这么多 Goroutine？
**A**: 因为栈小（2KB），切换成本低（用户态），调度高效（M:N 模型）。

### Q3: Goroutine 会"饿死"吗？
**A**: 不会。Go 1.14+ 有抢占式调度，长时间运行的 G 会被强制让出 CPU。

### Q4: 如何控制 Goroutine 数量？
**A**: 用 Worker Pool 模式（channel + 固定数量的 worker goroutine）。

---

## 九、总结

**Goroutine 的核心优势**：
1. ✅ **轻量**：创建成本低，栈小
2. ✅ **高效**：用户态调度，切换成本低
3. ✅ **并发能力强**：可以创建百万级
4. ✅ **简单**：语法简单（`go func()`），无需管理线程

**适用场景**：
- IO 密集型任务（网络请求、文件读写）
- 并发处理大量小任务
- 需要高并发的服务（如 HTTP 服务器）

**不适合场景**：
- CPU 密集型任务（受限于 GOMAXPROCS，不会超过 CPU 核心数）
- 需要精确控制线程的场景（如 CGO 调用）

